"use strict";
(wx["webpackJsonp"] = wx["webpackJsonp"] || []).push([["vendors-node_modules_taro_weapp_prebundle_cube-common-lib_js"],{

/***/ "./node_modules/.taro/weapp/prebundle/chunk-P7VEE7PG.js":
/*!**************************************************************!*\
  !*** ./node_modules/.taro/weapp/prebundle/chunk-P7VEE7PG.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__commonJS": function() { return /* binding */ __commonJS; },
/* harmony export */   "__esm": function() { return /* binding */ __esm; },
/* harmony export */   "__export": function() { return /* binding */ __export; },
/* harmony export */   "__toCommonJS": function() { return /* binding */ __toCommonJS; },
/* harmony export */   "__toESM": function() { return /* binding */ __toESM; }
/* harmony export */ });
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res)=>function __init() {
        return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
    };
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);



/***/ }),

/***/ "./node_modules/.taro/weapp/prebundle/cube-common-lib.js":
/*!***************************************************************!*\
  !*** ./node_modules/.taro/weapp/prebundle/cube-common-lib.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ABPErrorDto": function() { return /* binding */ ABPErrorDto; },
/* harmony export */   "ArrayUtil": function() { return /* binding */ ArrayUtil; },
/* harmony export */   "BaseAttachmentCreateRequest": function() { return /* binding */ BaseAttachmentCreateRequest; },
/* harmony export */   "BaseErrorResponse": function() { return /* binding */ BaseErrorResponse; },
/* harmony export */   "BaseIdResponse": function() { return /* binding */ BaseIdResponse; },
/* harmony export */   "BaseListRequest": function() { return /* binding */ BaseListRequest; },
/* harmony export */   "BaseResponse": function() { return /* binding */ BaseResponse; },
/* harmony export */   "BaseUploadRequest": function() { return /* binding */ BaseUploadRequest; },
/* harmony export */   "BasicTypeValueConverter": function() { return /* binding */ BasicTypeValueConverter; },
/* harmony export */   "CommonUtils": function() { return /* binding */ CommonUtils; },
/* harmony export */   "ContentTypeName": function() { return /* binding */ ContentTypeName; },
/* harmony export */   "CubePhone": function() { return /* binding */ CubePhone; },
/* harmony export */   "CubePontBasicRequest": function() { return /* binding */ CubePontBasicRequest; },
/* harmony export */   "CubePontBasicRequestConfig": function() { return /* binding */ CubePontBasicRequestConfig; },
/* harmony export */   "DateUtils": function() { return /* binding */ DateUtils; },
/* harmony export */   "FileUtils": function() { return /* binding */ FileUtils; },
/* harmony export */   "GetDateOptions": function() { return /* binding */ GetDateOptions; },
/* harmony export */   "HtmlRegExp": function() { return /* binding */ HtmlRegExp; },
/* harmony export */   "I18nLocaleEnum": function() { return /* binding */ I18nLocaleEnum; },
/* harmony export */   "I18nUtil": function() { return /* binding */ I18nUtil; },
/* harmony export */   "Md5Utils": function() { return /* binding */ Md5Utils; },
/* harmony export */   "NameValueActiveDto": function() { return /* binding */ NameValueActiveDto; },
/* harmony export */   "NameValueChildrenActiveDto": function() { return /* binding */ NameValueChildrenActiveDto; },
/* harmony export */   "NameValueChildrenDto": function() { return /* binding */ NameValueChildrenDto; },
/* harmony export */   "NameValueDto": function() { return /* binding */ NameValueDto; },
/* harmony export */   "NameValueIconActiveDto": function() { return /* binding */ NameValueIconActiveDto; },
/* harmony export */   "NameValueIconChildrenActiveDto": function() { return /* binding */ NameValueIconChildrenActiveDto; },
/* harmony export */   "NetWorkConfig": function() { return /* binding */ NetWorkConfig; },
/* harmony export */   "NetworkUtil": function() { return /* binding */ NetworkUtil; },
/* harmony export */   "NotificationCenter": function() { return /* binding */ NotificationCenter; },
/* harmony export */   "NumberUtils": function() { return /* binding */ NumberUtils; },
/* harmony export */   "PhoneUtil": function() { return /* binding */ PhoneUtil; },
/* harmony export */   "PontParams": function() { return /* binding */ PontParams; },
/* harmony export */   "PontRequestConfig": function() { return /* binding */ PontRequestConfig; },
/* harmony export */   "PromiseAllSettled": function() { return /* binding */ PromiseAllSettled; },
/* harmony export */   "RegExpUtil": function() { return /* binding */ RegExpUtil; },
/* harmony export */   "SerializeUtil": function() { return /* binding */ SerializeUtil; },
/* harmony export */   "SetIframeRouteDisabled": function() { return /* binding */ SetIframeRouteDisabled; },
/* harmony export */   "SetNameByIntervalValue": function() { return /* binding */ SetNameByIntervalValue; },
/* harmony export */   "SetPropertyUtil": function() { return /* binding */ SetPropertyUtil; },
/* harmony export */   "SignMd5Utils": function() { return /* binding */ SignMd5Utils; },
/* harmony export */   "StringUtil": function() { return /* binding */ StringUtil; },
/* harmony export */   "createNetworkErrorResponseByCode": function() { return /* binding */ createNetworkErrorResponseByCode; }
/* harmony export */ });
/* harmony import */ var _chunk_P7VEE7PG_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-P7VEE7PG.js */ "./node_modules/.taro/weapp/prebundle/chunk-P7VEE7PG.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}

// node_modules/serializr/lib/serializr.es.js
var formatters = {
    j: function json(v) {
        try {
            return JSON.stringify(v);
        } catch (error) {
            return "[UnexpectedJSONParseError]: " + error.message;
        }
    },
    l: function symbol(s) {
        return s.toString();
    }
};
function invariant(condition, message) {
    var variables = [];
    for(var _i = 2; _i < arguments.length; _i++){
        variables[_i - 2] = arguments[_i];
    }
    if (!condition) {
        var variablesToLog_1 = [];
        var index_1 = 0;
        var formattedMessage = message.replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") return match;
            var formatter = formatters[format];
            if (typeof formatter === "function") {
                var variable = variables[index_1++];
                variablesToLog_1.push(variable);
                return formatter(variable);
            }
            return match;
        });
        if (console && variablesToLog_1.length > 0) {
            console.log.apply(console, variablesToLog_1);
        }
        throw new Error("[serializr] " + (formattedMessage || "Illegal State"));
    }
}
function GUARDED_NOOP(err) {
    if (err) throw new Error(err);
}
function once(fn) {
    var fired = false;
    return function() {
        if (!fired) {
            fired = true;
            return fn.apply(null, arguments);
        }
        invariant(false, "callback was invoked twice");
    };
}
function parallel(ar, processor, cb) {
    if (ar.length === 0) return void cb(null, []);
    var left = ar.filter(function(x) {
        return true;
    }).length;
    var resultArray = [];
    var failed = false;
    ar.forEach(function(value, idx) {
        processor(value, function(err, result) {
            if (err) {
                if (!failed) {
                    failed = true;
                    cb(err);
                }
            } else {
                resultArray[idx] = result;
                if (--left === 0) cb(null, resultArray);
            }
        }, idx);
    });
}
function isPrimitive(value) {
    if (value === null) return true;
    return typeof value !== "object" && typeof value !== "function";
}
function isModelSchema(thing) {
    return thing && thing.factory && thing.props;
}
function isPropSchema(thing) {
    return thing && thing.serializer && thing.deserializer;
}
function isAliasedPropSchema(propSchema) {
    return typeof propSchema === "object" && "string" == typeof propSchema.jsonname;
}
function isAssignableTo(actualType, expectedType) {
    var currentActualType = actualType;
    while(currentActualType){
        if (currentActualType === expectedType) return true;
        currentActualType = currentActualType.extends;
    }
    return false;
}
function processAdditionalPropArgs(propSchema, additionalArgs) {
    if (additionalArgs) {
        invariant(isPropSchema(propSchema), "expected a propSchema");
        Object.assign(propSchema, additionalArgs);
    }
    return propSchema;
}
function getDefaultModelSchema(thing) {
    if (!thing) return void 0;
    if (isModelSchema(thing)) return thing;
    if (isModelSchema(thing.serializeInfo)) return thing.serializeInfo;
    if (thing.constructor && thing.constructor.serializeInfo) return thing.constructor.serializeInfo;
}
function setDefaultModelSchema(clazz, modelSchema) {
    invariant(isModelSchema(modelSchema), "expected modelSchema, got " + modelSchema);
    clazz.serializeInfo = modelSchema;
    return modelSchema;
}
function createModelSchema(clazz, props, factory) {
    invariant(clazz !== Object, "one cannot simply put define a model schema for Object");
    invariant(typeof clazz === "function", "expected constructor function");
    var model = {
        targetClass: clazz,
        factory: factory || function() {
            return new clazz();
        },
        props
    };
    if (clazz.prototype.constructor !== Object) {
        var s = getDefaultModelSchema(clazz.prototype.constructor);
        if (s && s.targetClass !== clazz) model.extends = s;
    }
    setDefaultModelSchema(clazz, model);
    return model;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function primitive(additionalArgs) {
    var result = {
        serializer: function(value) {
            invariant(isPrimitive(value), "this value is not primitive: " + value);
            return value;
        },
        deserializer: function(jsonValue, done) {
            if (!isPrimitive(jsonValue)) return void done("[serializr] this value is not primitive: " + jsonValue);
            return void done(null, jsonValue);
        }
    };
    result = processAdditionalPropArgs(result, additionalArgs);
    return result;
}
var SKIP = typeof Symbol !== "undefined" ? Symbol("SKIP") : {
    SKIP: true
};
var _defaultPrimitiveProp = primitive();
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
var ARGUMENT_NAMES = /([^\s,]+)/g;
function getParamNames(func) {
    var _a;
    var fnStr = func.toString().replace(STRIP_COMMENTS, "");
    return (_a = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(ARGUMENT_NAMES)) !== null && _a !== void 0 ? _a : [];
}
function serializableDecorator(propSchema, target, propName, descriptor) {
    invariant(arguments.length >= 2, "too few arguments. Please use @serializable as property decorator");
    var factory;
    if (propName === void 0 && typeof target === "function" && target.prototype && descriptor !== void 0 && typeof descriptor === "number") {
        invariant(isPropSchema(propSchema), "Constructor params must use alias(name)");
        invariant(isAliasedPropSchema(propSchema), "Constructor params must use alias(name)");
        var paramNames = getParamNames(target);
        if (paramNames.length >= descriptor) {
            propName = paramNames[descriptor];
            propSchema.paramNumber = descriptor;
            descriptor = void 0;
            target = target.prototype;
            factory = function(context) {
                var _a;
                var params = [];
                var _loop_1 = function(i2) {
                    Object.keys(context.modelSchema.props).forEach(function(key) {
                        var prop = context.modelSchema.props[key];
                        if (prop.paramNumber === i2) {
                            params[i2] = context.json[prop.jsonname];
                        }
                    });
                };
                for(var i = 0; i < target.constructor.length; i++){
                    _loop_1(i);
                }
                return (_a = target.constructor).bind.apply(_a, __spreadArrays([
                    void 0
                ], params));
            };
        }
    }
    invariant(typeof propName === "string", "incorrect usage of @serializable decorator");
    var info = getDefaultModelSchema(target);
    if (!info || !target.constructor.hasOwnProperty("serializeInfo")) info = createModelSchema(target.constructor, {}, factory);
    if (info && info.targetClass !== target.constructor) info = createModelSchema(target.constructor, {}, factory);
    info.props[propName] = propSchema;
    if (descriptor && !descriptor.get && !descriptor.set) descriptor.writable = true;
    return descriptor;
}
function serializable(targetOrPropSchema, key, baseDescriptor) {
    if (!key) {
        var propSchema = targetOrPropSchema === true ? _defaultPrimitiveProp : targetOrPropSchema;
        invariant(isPropSchema(propSchema), "@serializable expects prop schema");
        var result = serializableDecorator.bind(null, propSchema);
        return result;
    } else {
        serializableDecorator(primitive(), targetOrPropSchema, key, baseDescriptor);
    }
}
function serialize(modelSchemaOrInstance, arg2) {
    invariant(arguments.length === 1 || arguments.length === 2, "serialize expects one or 2 arguments");
    var instance = arg2 !== null && arg2 !== void 0 ? arg2 : modelSchemaOrInstance;
    var schema = arg2 && modelSchemaOrInstance;
    if (Array.isArray(instance)) {
        if (instance.length === 0) return [];
        else if (!schema) schema = getDefaultModelSchema(instance[0]);
        else if (typeof schema !== "object") schema = getDefaultModelSchema(schema);
    } else if (!schema) {
        schema = getDefaultModelSchema(instance);
    } else if (typeof schema !== "object") {
        schema = getDefaultModelSchema(schema);
    }
    var foundSchema = schema;
    if (!foundSchema) {
        invariant(foundSchema, "Failed to find default schema for " + modelSchemaOrInstance);
    }
    if (Array.isArray(instance)) return instance.map(function(item) {
        return serializeWithSchema(foundSchema, item);
    });
    return serializeWithSchema(foundSchema, instance);
}
function serializeWithSchema(schema, obj) {
    invariant(schema && typeof schema === "object" && schema.props, "Expected schema");
    invariant(obj && typeof obj === "object", "Expected object");
    var res;
    if (schema.extends) res = serializeWithSchema(schema.extends, obj);
    else {
        res = {};
    }
    Object.keys(schema.props).forEach(function(key) {
        var propDef = schema.props[key];
        if (!propDef) return;
        if (key === "*") {
            serializeStarProps(schema, propDef, obj, res);
            return;
        }
        if (propDef === true) propDef = _defaultPrimitiveProp;
        var jsonValue = propDef.serializer(obj[key], key, obj);
        if (jsonValue === SKIP) {
            return;
        }
        res[propDef.jsonname || key] = jsonValue;
    });
    return res;
}
function serializeStarProps(schema, propDef, obj, target) {
    for(var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++){
        var key = _a[_i];
        if (!(key in schema.props)) {
            if (propDef === true || propDef && (!propDef.pattern || propDef.pattern.test(key))) {
                var value = obj[key];
                if (propDef === true) {
                    if (isPrimitive(value)) {
                        target[key] = value;
                    }
                } else {
                    var jsonValue = propDef.serializer(value, key, obj);
                    if (jsonValue === SKIP) {
                        return;
                    }
                    target[key] = jsonValue;
                }
            }
        }
    }
}
var rootContextCache = /* @__PURE__ */ new WeakMap();
var Context = function() {
    function Context2(parentContext, modelSchema, json2, onReadyCb, customArgs) {
        this.parentContext = parentContext;
        this.modelSchema = modelSchema;
        this.json = json2;
        this.onReadyCb = onReadyCb;
        this.isRoot = !parentContext;
        this.pendingCallbacks = 0;
        this.pendingRefsCount = 0;
        this.target = void 0;
        this.hasError = false;
        if (!parentContext) {
            this.rootContext = this;
            this.args = customArgs;
            this.pendingRefs = {};
            this.resolvedRefs = {};
        } else {
            this.rootContext = parentContext.rootContext;
            this.args = parentContext.args;
        }
    }
    Context2.prototype.createCallback = function(fn) {
        var _this = this;
        this.pendingCallbacks++;
        return once(function(err, value) {
            if (err) {
                if (!_this.hasError) {
                    _this.hasError = true;
                    _this.onReadyCb(err);
                    rootContextCache.delete(_this);
                }
            } else if (!_this.hasError) {
                fn(value);
                if (--_this.pendingCallbacks === _this.pendingRefsCount) {
                    if (_this.pendingRefsCount > 0) {
                        _this.onReadyCb(new Error('Unresolvable references in json: "' + Object.keys(_this.pendingRefs).filter(function(uuid) {
                            return _this.pendingRefs[uuid].length > 0;
                        }).join('", "') + '"'));
                        rootContextCache.delete(_this);
                    } else {
                        _this.onReadyCb(null, _this.target);
                        rootContextCache.delete(_this);
                    }
                }
            }
        });
    };
    Context2.prototype.await = function(modelSchema, uuid, callback) {
        invariant(this.isRoot, "await can only be called on the root context");
        if (uuid in this.resolvedRefs) {
            var match = this.resolvedRefs[uuid].filter(function(resolved) {
                return isAssignableTo(resolved.modelSchema, modelSchema);
            })[0];
            if (match) return void callback(null, match.value);
        }
        this.pendingRefsCount++;
        if (!this.pendingRefs[uuid]) this.pendingRefs[uuid] = [];
        this.pendingRefs[uuid].push({
            modelSchema,
            uuid,
            callback
        });
    };
    Context2.prototype.resolve = function(modelSchema, uuid, value) {
        invariant(this.isRoot, "resolve can only called on the root context");
        if (!this.resolvedRefs[uuid]) this.resolvedRefs[uuid] = [];
        this.resolvedRefs[uuid].push({
            modelSchema,
            value
        });
        if (uuid in this.pendingRefs) {
            for(var i = this.pendingRefs[uuid].length - 1; i >= 0; i--){
                var opts = this.pendingRefs[uuid][i];
                if (isAssignableTo(modelSchema, opts.modelSchema)) {
                    this.pendingRefs[uuid].splice(i, 1);
                    this.pendingRefsCount--;
                    opts.callback(null, value);
                }
            }
        }
    };
    Context2.prototype.setTarget = function(target) {
        if (this.isRoot && this.target) {
            rootContextCache.delete(this.target);
        }
        this.target = target;
        rootContextCache.set(this.target, this);
    };
    Context2.prototype.cancelAwaits = function() {
        invariant(this.isRoot, "cancelAwaits can only be called on the root context");
        var self = this;
        Object.keys(this.pendingRefs).forEach(function(uuid) {
            self.pendingRefs[uuid].forEach(function(refOpts) {
                self.pendingRefsCount--;
                refOpts.callback(new Error("Reference resolution canceled for " + uuid));
            });
        });
        this.pendingRefs = {};
        this.pendingRefsCount = 0;
    };
    return Context2;
}();
function schemaHasAlias(schema, name) {
    for(var key in schema.props){
        var propSchema = schema.props[key];
        if (typeof propSchema === "object" && propSchema.jsonname === name) return true;
    }
    return false;
}
function deserializeStarProps(context, schema, propDef, obj, json2) {
    var _loop_1 = function(key2) {
        if (!(key2 in schema.props) && !schemaHasAlias(schema, key2)) {
            var jsonValue = json2[key2];
            if (propDef === true) {
                invariant(isPrimitive(jsonValue), "encountered non primitive value while deserializing '*' properties in property '" + key2 + "': " + jsonValue);
                obj[key2] = jsonValue;
            } else if (propDef && (!propDef.pattern || propDef.pattern.test(key2))) {
                propDef.deserializer(jsonValue, context.rootContext.createCallback(function(r) {
                    return r !== SKIP && (obj[key2] = r);
                }), context);
            }
        }
    };
    for(var key in json2){
        _loop_1(key);
    }
}
function deserialize(clazzOrModelSchema, json2, callback, customArgs) {
    if (callback === void 0) {
        callback = GUARDED_NOOP;
    }
    invariant(arguments.length >= 2, "deserialize expects at least 2 arguments");
    var schema = getDefaultModelSchema(clazzOrModelSchema);
    invariant(isModelSchema(schema), "first argument should be model schema");
    if (Array.isArray(json2)) {
        var items_1 = [];
        parallel(json2, function(childJson, itemDone) {
            var instance = deserializeObjectWithSchema(void 0, schema, childJson, itemDone, customArgs);
            items_1.push(instance);
        }, callback);
        return items_1;
    } else {
        return deserializeObjectWithSchema(void 0, schema, json2, callback, customArgs);
    }
}
function deserializeObjectWithSchema(parentContext, modelSchema, json2, callback, customArgs) {
    if (json2 === null || json2 === void 0 || typeof json2 !== "object") return void callback(null, null);
    var context = new Context(parentContext, modelSchema, json2, callback, customArgs);
    var target = modelSchema.factory(context);
    invariant(!!target, "No object returned from factory");
    context.setTarget(target);
    var lock = context.createCallback(GUARDED_NOOP);
    deserializePropsWithSchema(context, modelSchema, json2, target);
    lock();
    return target;
}
function deserializePropsWithSchema(context, modelSchema, json2, target) {
    var _a;
    if (modelSchema.extends) deserializePropsWithSchema(context, modelSchema.extends, json2, target);
    function deserializeProp(propDef, jsonValue, propName) {
        var whenDone = context.rootContext.createCallback(function(r) {
            return r !== SKIP && (target[propName] = r);
        });
        propDef.deserializer(jsonValue, function(err, newValue) {
            return onAfterDeserialize(whenDone, err, newValue, jsonValue, json2, propName, context, propDef);
        }, context, target[propName]);
    }
    var _loop_2 = function(key2) {
        var propDef = modelSchema.props[key2];
        if (!propDef) return {
            value: void 0
        };
        if (key2 === "*") {
            deserializeStarProps(context, modelSchema, propDef, target, json2);
            return {
                value: void 0
            };
        }
        if (propDef === true) propDef = _defaultPrimitiveProp;
        var jsonAttr = (_a = propDef.jsonname) !== null && _a !== void 0 ? _a : key2;
        invariant("symbol" !== typeof jsonAttr, "You must alias symbol properties. prop = %l", key2);
        var jsonValue = json2[jsonAttr];
        var propSchema = propDef;
        var callbackDeserialize = function(err, jsonValue2) {
            if (!err && jsonValue2 !== void 0) {
                deserializeProp(propSchema, jsonValue2, key2);
            }
        };
        onBeforeDeserialize(callbackDeserialize, jsonValue, json2, jsonAttr, context, propDef);
    };
    for(var _i = 0, _b = Object.keys(modelSchema.props); _i < _b.length; _i++){
        var key = _b[_i];
        var state_1 = _loop_2(key);
        if (typeof state_1 === "object") return state_1.value;
    }
}
var onBeforeDeserialize = function(callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {
    if (propDef && typeof propDef.beforeDeserialize === "function") {
        propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef);
    } else {
        callback(null, jsonValue);
    }
};
var onAfterDeserialize = function(callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {
    if (propDef && typeof propDef.afterDeserialize === "function") {
        propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef);
    } else {
        callback(err, newValue);
    }
};
function object(modelSchema, additionalArgs) {
    invariant(typeof modelSchema === "object" || typeof modelSchema === "function", "No modelschema provided. If you are importing it from another file be aware of circular dependencies.");
    var result = {
        serializer: function(item) {
            modelSchema = getDefaultModelSchema(modelSchema);
            invariant(isModelSchema(modelSchema), "expected modelSchema, got " + modelSchema);
            if (item === null || item === void 0) return item;
            return serialize(modelSchema, item);
        },
        deserializer: function(childJson, done, context) {
            modelSchema = getDefaultModelSchema(modelSchema);
            invariant(isModelSchema(modelSchema), "expected modelSchema, got " + modelSchema);
            if (childJson === null || childJson === void 0) return void done(null, childJson);
            return void deserializeObjectWithSchema(context, modelSchema, childJson, done, void 0);
        }
    };
    result = processAdditionalPropArgs(result, additionalArgs);
    return result;
}
// node_modules/cube-common-lib/dist/index.es.js
var BaseUploadRequest = class {
    constructor(){
        this.Name = "file";
    }
};
var I18nLocaleEnum;
(function(I18nLocaleEnum2) {
    I18nLocaleEnum2["En"] = "en_US";
    I18nLocaleEnum2["Cn"] = "zh_CN";
    I18nLocaleEnum2["Mo"] = "zh_TW";
})(I18nLocaleEnum || (I18nLocaleEnum = {}));
var Md5Utils = (string)=>{
    function RotateLeft(lValue, iShiftBits) {
        return lValue << iShiftBits | lValue >>> 32 - iShiftBits;
    }
    function AddUnsigned(lX, lY) {
        let lX4, lY4, lX8, lY8, lResult;
        lX8 = lX & 2147483648;
        lY8 = lY & 2147483648;
        lX4 = lX & 1073741824;
        lY4 = lY & 1073741824;
        lResult = (lX & 1073741823) + (lY & 1073741823);
        if (lX4 & lY4) {
            return lResult ^ 2147483648 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
            if (lResult & 1073741824) {
                return lResult ^ 3221225472 ^ lX8 ^ lY8;
            } else {
                return lResult ^ 1073741824 ^ lX8 ^ lY8;
            }
        } else {
            return lResult ^ lX8 ^ lY8;
        }
    }
    function F(x2, y, z) {
        return x2 & y | ~x2 & z;
    }
    function G(x2, y, z) {
        return x2 & z | y & ~z;
    }
    function H(x2, y, z) {
        return x2 ^ y ^ z;
    }
    function I(x2, y, z) {
        return y ^ (x2 | ~z);
    }
    function FF(a2, b2, c2, d2, x2, s, ac) {
        a2 = AddUnsigned(a2, AddUnsigned(AddUnsigned(F(b2, c2, d2), x2), ac));
        return AddUnsigned(RotateLeft(a2, s), b2);
    }
    function GG(a2, b2, c2, d2, x2, s, ac) {
        a2 = AddUnsigned(a2, AddUnsigned(AddUnsigned(G(b2, c2, d2), x2), ac));
        return AddUnsigned(RotateLeft(a2, s), b2);
    }
    function HH(a2, b2, c2, d2, x2, s, ac) {
        a2 = AddUnsigned(a2, AddUnsigned(AddUnsigned(H(b2, c2, d2), x2), ac));
        return AddUnsigned(RotateLeft(a2, s), b2);
    }
    function II(a2, b2, c2, d2, x2, s, ac) {
        a2 = AddUnsigned(a2, AddUnsigned(AddUnsigned(I(b2, c2, d2), x2), ac));
        return AddUnsigned(RotateLeft(a2, s), b2);
    }
    function ConvertToWordArray(string2) {
        var lWordCount;
        var lMessageLength = string2.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while(lByteCount < lMessageLength){
            lWordCount = (lByteCount - lByteCount % 4) / 4;
            lBytePosition = lByteCount % 4 * 8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | string2.charCodeAt(lByteCount) << lBytePosition;
            lByteCount++;
        }
        lWordCount = (lByteCount - lByteCount % 4) / 4;
        lBytePosition = lByteCount % 4 * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition;
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    }
    function WordToHex(lValue) {
        var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
        for(lCount = 0; lCount <= 3; lCount++){
            lByte = lValue >>> lCount * 8 & 255;
            WordToHexValue_temp = "0" + lByte.toString(16);
            WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
    }
    function Utf8Encode(string2) {
        string2 = string2.replace(/\r\n/g, "\n");
        var utftext = "";
        for(var n = 0; n < string2.length; n++){
            var c2 = string2.charCodeAt(n);
            if (c2 < 128) {
                utftext += String.fromCharCode(c2);
            } else if (c2 > 127 && c2 < 2048) {
                utftext += String.fromCharCode(c2 >> 6 | 192);
                utftext += String.fromCharCode(c2 & 63 | 128);
            } else {
                utftext += String.fromCharCode(c2 >> 12 | 224);
                utftext += String.fromCharCode(c2 >> 6 & 63 | 128);
                utftext += String.fromCharCode(c2 & 63 | 128);
            }
        }
        return utftext;
    }
    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
    var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
    var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
    var S41 = 6, S42 = 10, S43 = 15, S44 = 21;
    string = Utf8Encode(string);
    x = ConvertToWordArray(string);
    a = 1732584193;
    b = 4023233417;
    c = 2562383102;
    d = 271733878;
    for(k = 0; k < x.length; k += 16){
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 3614090360);
        d = FF(d, a, b, c, x[k + 1], S12, 3905402710);
        c = FF(c, d, a, b, x[k + 2], S13, 606105819);
        b = FF(b, c, d, a, x[k + 3], S14, 3250441966);
        a = FF(a, b, c, d, x[k + 4], S11, 4118548399);
        d = FF(d, a, b, c, x[k + 5], S12, 1200080426);
        c = FF(c, d, a, b, x[k + 6], S13, 2821735955);
        b = FF(b, c, d, a, x[k + 7], S14, 4249261313);
        a = FF(a, b, c, d, x[k + 8], S11, 1770035416);
        d = FF(d, a, b, c, x[k + 9], S12, 2336552879);
        c = FF(c, d, a, b, x[k + 10], S13, 4294925233);
        b = FF(b, c, d, a, x[k + 11], S14, 2304563134);
        a = FF(a, b, c, d, x[k + 12], S11, 1804603682);
        d = FF(d, a, b, c, x[k + 13], S12, 4254626195);
        c = FF(c, d, a, b, x[k + 14], S13, 2792965006);
        b = FF(b, c, d, a, x[k + 15], S14, 1236535329);
        a = GG(a, b, c, d, x[k + 1], S21, 4129170786);
        d = GG(d, a, b, c, x[k + 6], S22, 3225465664);
        c = GG(c, d, a, b, x[k + 11], S23, 643717713);
        b = GG(b, c, d, a, x[k + 0], S24, 3921069994);
        a = GG(a, b, c, d, x[k + 5], S21, 3593408605);
        d = GG(d, a, b, c, x[k + 10], S22, 38016083);
        c = GG(c, d, a, b, x[k + 15], S23, 3634488961);
        b = GG(b, c, d, a, x[k + 4], S24, 3889429448);
        a = GG(a, b, c, d, x[k + 9], S21, 568446438);
        d = GG(d, a, b, c, x[k + 14], S22, 3275163606);
        c = GG(c, d, a, b, x[k + 3], S23, 4107603335);
        b = GG(b, c, d, a, x[k + 8], S24, 1163531501);
        a = GG(a, b, c, d, x[k + 13], S21, 2850285829);
        d = GG(d, a, b, c, x[k + 2], S22, 4243563512);
        c = GG(c, d, a, b, x[k + 7], S23, 1735328473);
        b = GG(b, c, d, a, x[k + 12], S24, 2368359562);
        a = HH(a, b, c, d, x[k + 5], S31, 4294588738);
        d = HH(d, a, b, c, x[k + 8], S32, 2272392833);
        c = HH(c, d, a, b, x[k + 11], S33, 1839030562);
        b = HH(b, c, d, a, x[k + 14], S34, 4259657740);
        a = HH(a, b, c, d, x[k + 1], S31, 2763975236);
        d = HH(d, a, b, c, x[k + 4], S32, 1272893353);
        c = HH(c, d, a, b, x[k + 7], S33, 4139469664);
        b = HH(b, c, d, a, x[k + 10], S34, 3200236656);
        a = HH(a, b, c, d, x[k + 13], S31, 681279174);
        d = HH(d, a, b, c, x[k + 0], S32, 3936430074);
        c = HH(c, d, a, b, x[k + 3], S33, 3572445317);
        b = HH(b, c, d, a, x[k + 6], S34, 76029189);
        a = HH(a, b, c, d, x[k + 9], S31, 3654602809);
        d = HH(d, a, b, c, x[k + 12], S32, 3873151461);
        c = HH(c, d, a, b, x[k + 15], S33, 530742520);
        b = HH(b, c, d, a, x[k + 2], S34, 3299628645);
        a = II(a, b, c, d, x[k + 0], S41, 4096336452);
        d = II(d, a, b, c, x[k + 7], S42, 1126891415);
        c = II(c, d, a, b, x[k + 14], S43, 2878612391);
        b = II(b, c, d, a, x[k + 5], S44, 4237533241);
        a = II(a, b, c, d, x[k + 12], S41, 1700485571);
        d = II(d, a, b, c, x[k + 3], S42, 2399980690);
        c = II(c, d, a, b, x[k + 10], S43, 4293915773);
        b = II(b, c, d, a, x[k + 1], S44, 2240044497);
        a = II(a, b, c, d, x[k + 8], S41, 1873313359);
        d = II(d, a, b, c, x[k + 15], S42, 4264355552);
        c = II(c, d, a, b, x[k + 6], S43, 2734768916);
        b = II(b, c, d, a, x[k + 13], S44, 1309151649);
        a = II(a, b, c, d, x[k + 4], S41, 4149444226);
        d = II(d, a, b, c, x[k + 11], S42, 3174756917);
        c = II(c, d, a, b, x[k + 2], S43, 718787259);
        b = II(b, c, d, a, x[k + 9], S44, 3951481745);
        a = AddUnsigned(a, AA);
        b = AddUnsigned(b, BB);
        c = AddUnsigned(c, CC);
        d = AddUnsigned(d, DD);
    }
    var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);
    return temp.toLowerCase();
};
var SignMd5Utils = class {
    static setAts(ats) {
        SignMd5Utils.ats = ats;
    }
    static hasAts() {
        return !!SignMd5Utils.ats;
    }
    static sortAsc(jsonObj) {
        let arr = new Array();
        let num = 0;
        for(let i in jsonObj){
            arr[num] = i;
            num++;
        }
        let sortArr = arr.sort();
        let sortObj = {};
        for(let i1 in sortArr){
            sortObj[sortArr[i1]] = jsonObj[sortArr[i1]];
        }
        return sortObj;
    }
    static getNigs(url, requestParams, sss) {
        const s = SignMd5Utils.ats || sss || "", i = requestParams.tm % s.length || 0;
        const s1 = s.slice(0, i), s2 = s.slice(i);
        const queryStr = SignMd5Utils.getQueryStr(requestParams);
        const beforeSign = s1 + url + queryStr + requestParams.tm + s2;
        return Md5Utils(beforeSign).toUpperCase() + ";2";
    }
    static parseQueryString(url) {
        let urlReg = /^[^\?]+\?([\w\W]+)$/, paramReg = /([^&=]+)=([\w\W]*?)(&|$|#)/g, urlArray = urlReg.exec(url), result = {};
        if (urlArray && urlArray[1]) {
            let paramString = urlArray[1], paramResult;
            while((paramResult = paramReg.exec(paramString)) != null){
                result[paramResult[1]] = paramResult[2];
            }
        }
        return result;
    }
    static mergeObject(objectOne, objectTwo) {
        if (Object.keys(objectTwo).length > 0) {
            for(let key in objectTwo){
                if (objectTwo.hasOwnProperty(key) === true) {
                    objectOne[key] = objectTwo[key];
                }
            }
        }
        return objectOne;
    }
    static urlEncode(param, key, encode) {
        if (param == null) return "";
        let paramStr = "";
        let t = typeof param;
        if (t == "string" || t == "number" || t == "boolean") {
            paramStr += "&" + key + "=" + (encode == null || encode ? encodeURIComponent(param) : param);
        } else {
            for(let i in param){
                let k = key == null ? i : key + (param instanceof Array ? "[" + i + "]" : "." + i);
                paramStr += this.urlEncode(param[i], k, encode);
            }
        }
        return paramStr;
    }
    static handle(params, header, url, sortArr = true, sss = "", rm = true) {
        params = params || {};
        header = header || {};
        for(const key in params){
            let val = params[key];
            params[key] = val = typeof val == "boolean" ? ~~val : val;
            if (rm && (val === null || val === void 0 || val === "")) {
                delete params[key];
            } else if (sortArr && Array.isArray(val)) {
                params[key] = val.sort();
            }
        }
        params.tm = Math.floor(Date.now() / 1e3);
        params = SignMd5Utils.sortAsc(params);
        header.s = SignMd5Utils.getNigs(url, params, sss);
        header.tm = params.tm;
        delete params.tm;
        return {
            params,
            header
        };
    }
    static fixedEncodeURIComponent(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
    }
    static getQueryStr(query) {
        let arr = [];
        for(const key in query){
            let v = query[key];
            if (v !== void 0) {
                v = v === null ? "" : v;
                if (Array.isArray(v)) {
                    for (const iv of v){
                        arr.push(key + "=" + SignMd5Utils.fixedEncodeURIComponent(iv));
                    }
                } else {
                    arr.push(key + "=" + SignMd5Utils.fixedEncodeURIComponent(v));
                }
            }
        }
        return arr.length ? "?" + arr.join("&") : "";
    }
};
SignMd5Utils.ats = "";
var StringUtil = class {
    static regArg(str) {
        str = typeof str == "string" ? str : "";
        const arr = [
            "\\",
            "(",
            "[",
            "{",
            "^",
            "$",
            "|",
            ")",
            "?",
            "*",
            "+",
            ".",
            "]",
            "}"
        ];
        arr.forEach((s)=>{
            str = str.replace(s, "\\" + s);
        });
        return str;
    }
    static getFormatFileSizeString(fileSize, withB = false) {
        let result = "";
        const b = withB ? "B" : "";
        if (fileSize < 1024) {
            result = fileSize + b;
        } else if (fileSize < Math.pow(1024, 2)) {
            result = Math.round(fileSize / 1024) + "K" + b;
        } else if (fileSize < Math.pow(1024, 3)) {
            result = Math.round(fileSize / Math.pow(1024, 2)) + "M" + b;
        } else if (fileSize < Math.pow(1024, 4)) {
            result = Math.round(fileSize / Math.pow(1024, 3)) + "G" + b;
        } else {
            result = Math.round(fileSize / Math.pow(1024, 4)) + "T" + b;
        }
        return result;
    }
    static isNull(str) {
        return !str || str.trim().length === 0;
    }
    static toString(value) {
        const type = typeof value;
        if (type == "string" || type == "number") {
            return value + "";
        } else {
            return "";
        }
    }
    static cutNumber(value, point = 0, hasMinusSign = false) {
        let inputValue = value;
        if (point > 0) {
            if (value.startsWith(".")) {
                value = "0" + value;
            }
            value = value.replace(/[^\d.]/g, "");
            value = value.replace(/\.{2,}/g, ".");
            value = value.replace(".", "$#$").replace(/\./g, "").replace("$#$", ".");
            value = value.replace(new RegExp(`^(\\-)*(\\d+)\\.(\\d{${point}}).*$`), "$1$2.$3");
            if (value.indexOf(".") < 0 && value != "") {
                value = parseFloat(value).toString();
            }
        } else {
            value = value.replace(/[^\d]/g, "");
        }
        if (hasMinusSign && inputValue && inputValue.charAt(0) === "-") {
            value = "-" + value;
        }
        return value;
    }
    static format(value) {
        const v = value + "";
        let i = v.length, res = "", sum = "", dot = "";
        if (v.indexOf(".") >= 0) {
            i = v.indexOf(".");
            dot = v.substring(v.length, v.indexOf("."));
            sum = sum || "0";
        }
        sum = v.substring(0, i).replace(/\B(?=(?:\d{3})+$)/g, ",");
        res = sum + dot;
        return res;
    }
    static cutNumberLetterPoint(str) {
        str = str && typeof str == "string" ? str : "";
        return str.replace(/[^a-z^A-Z^0-9^\.\/]/g, "");
    }
    static cutNumberLetter(str) {
        str = str && typeof str == "string" ? str : "";
        return str.replace(/[^a-z^A-Z^0-9]/g, "");
    }
    static urlConcat(root, path) {
        if (root[root.length - 1] == "/") {
            root = root.slice(0, -1);
        }
        if (path[0] == "/") {
            path = path.slice(1);
        }
        return root + "/" + path;
    }
    static getUrlFromString(str) {
        const reg = /(https?|http|ftp|file):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/g;
        const res = str.match(reg) || [];
        return res;
    }
    static splitMsg(msg) {
        let res = [];
        const arr = StringUtil.getUrlFromString(msg);
        let is = [];
        arr.forEach((url)=>{
            is.push(msg.indexOf(url), url.length);
        });
        for(let i = 0; i < is.length; i += 2){
            const s = msg.substring(is[i - 2] + is[i - 1], is[i]) || "";
            res.push({
                isUrl: false,
                value: s
            });
            const a = msg.substr(is[i], is[i + 1]) || "";
            res.push({
                isUrl: true,
                value: a
            });
        }
        const e = msg.substring(is[is.length - 2] + is[is.length - 1]);
        res.push({
            isUrl: false,
            value: e
        });
        return res;
    }
    static isJson(str) {
        try {
            if (str && typeof JSON.parse(str) == "object") {
                return true;
            }
        } catch (e) {}
        return false;
    }
    static getPriceI18n(price, isEn = false, format = false) {
        let num = Number(price);
        if (isEn) {
            num /= 100;
        }
        let str = num.toFixed(2);
        if (str.includes(".")) {
            if (str[str.length - 1] == "0") {
                str = str.slice(0, str.length - 1);
            }
            if (str[str.length - 1] == "0") {
                str = str.slice(0, str.length - 1);
            }
            if (str[str.length - 1] == ".") {
                str = str.slice(0, str.length - 1);
            }
        }
        return format ? StringUtil.format(str) : str + "";
    }
    static randomKey() {
        const t = "xxxxxxxx";
        return t.replace(/[xy]/g, (c)=>{
            const r = Math.random() * 16 | 0;
            const v = c === "x" ? r : r & 3 | 8;
            return v.toString(16);
        });
    }
    static isEmail(str) {
        str = typeof str == "string" ? str : "";
        return /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.test(str);
    }
    static formatEmail(email, separator = "") {
        const t = this.isEmail;
        const m = (email || "").replace(/[\r\n\s]*/g, "");
        if (!separator) {
            return m ? t(m) ? m : "" : "";
        } else {
            const arr = m ? m.split(separator).filter((a)=>!!a && t(a)) : [];
            return arr.join(separator);
        }
    }
    static splitByKeyword(word, keyword, tagName, className) {
        const kw = typeof keyword == "string" ? keyword.trim() : "", w = typeof word == "string" ? word : "", cn = typeof className == "string" ? className : Array.isArray(className) ? className.join(" ") : "";
        if (kw && w) {
            const reg = new RegExp(StringUtil.regArg(kw), "gi");
            const ns = w.split(reg), ks = [];
            let sa = null;
            if (ns.length > 1) {
                while((sa = reg.exec(w)) != null){
                    ks.push(sa[0]);
                }
                let res = "";
                ns.forEach((n, i)=>{
                    const k = ks[i] ? cn ? `<${tagName} class="${cn}">${ks[i]}</${tagName}>` : `<${tagName}>${ks[i]}</${tagName}>` : "";
                    res += n + k;
                });
                return res;
            }
            return w;
        }
        return w;
    }
    static phoneSplit(...phones) {
        const res = [];
        for(let i = 0; i < phones.length; i++){
            const phone = phones[i];
            if (phone && typeof phone == "string") {
                const arr = phone.split(/[^\d\+]+/g).filter((s)=>!!s);
                let c = "", p = "";
                for(let i2 = 0; i2 < arr.length; i2++){
                    const n = arr[i2];
                    if (/^\+?853$|^\+?852$|^\+?86$/.test(n)) {
                        if (p) {
                            res.push(c ? `${c} ${p}` : p);
                        }
                        c = n;
                        p = "";
                    } else {
                        const x = n.replace(/[^\d]/g, "");
                        if (!p) {
                            p += x;
                        } else if (p.length >= 8 || (p + x).length > 11) {
                            res.push(c ? `${c} ${p}` : p);
                            c = "";
                            p = x;
                        } else {
                            p += x;
                        }
                    }
                }
                res.push(c ? `${c} ${p}` : p);
            }
        }
        return res.filter((s)=>!!s);
    }
};
var NWConfig = class {
    constructor(){
        this.basicUrl = "";
        this.accessToken = "";
        this.isRequestParamsEncry = false;
        this.uploadFileInterface = null;
        this.uploadFileProgressInterface = null;
        this.header = void 0;
        this.httpRequestService = null;
    }
};
var NetWorkConfig = class extends NWConfig {
    get set() {
        return (config)=>{
            if (config && typeof config == "object") {
                for(const key in config){
                    if (this.hasOwnProperty(key)) {
                        this[key] = config[key];
                    }
                }
            }
            return this;
        };
    }
};
var NetworkUtil = class {
    static setHttpRequestService(httpRequestService, APIKEY) {
        const config = NetworkUtil.getConfig(APIKEY);
        config.httpRequestService = httpRequestService;
        NetworkUtil.setConfig(config, APIKEY);
    }
    static getHttpRequestService(APIKEY) {
        return NetworkUtil.getConfig(APIKEY).httpRequestService;
    }
    static getConfig(APIKEY) {
        const key = APIKEY || NetworkUtil._defaultKey;
        return NetworkUtil._map.has(key) ? NetworkUtil._map.get(key) || new NetWorkConfig() : new NetWorkConfig();
    }
    static setConfig(config, APIKEY) {
        const key = APIKEY || NetworkUtil._defaultKey;
        let item = NetworkUtil.getConfig(key);
        if (item && item.set) {
            item = item.set(config);
        }
        NetworkUtil._map.set(key, item);
    }
    static setHeaderAttr(key, value, APIKEY) {
        const header = NetworkUtil.getRequestHeader(APIKEY);
        header[key] = value;
        NetworkUtil.setConfig({
            header
        }, APIKEY);
    }
    static removeHeaderAttr(key, APIKEY) {
        const header = NetworkUtil.getRequestHeader(APIKEY);
        delete header[key];
        NetworkUtil.setConfig({
            header
        }, APIKEY);
    }
    static setAccessToken(accessToken, APIKEY) {
        accessToken = accessToken || "";
        const header = NetworkUtil.getRequestHeader(APIKEY);
        const prefix = "Bearer ", token = accessToken.startsWith(prefix) ? accessToken : prefix + accessToken;
        header.Authorization = token;
        NetworkUtil.setConfig({
            accessToken,
            header
        }, APIKEY);
    }
    static removeAccessToken(APIKEY) {
        const header = NetworkUtil.getRequestHeader(APIKEY);
        delete header.Authorization;
        NetworkUtil.setConfig({
            accessToken: "",
            header
        }, APIKEY);
    }
    static getAccessToken(APIKEY) {
        return NetworkUtil.getConfig(APIKEY).accessToken;
    }
    static encryParams(params, header, url, APIKEY, data) {
        let fullUrl = NetworkUtil.getFullUrl(url, APIKEY);
        if (NetworkUtil.getConfig(APIKEY).isRequestParamsEncry) {
            const res = SignMd5Utils.handle(params, header, url);
            return {
                url: fullUrl,
                params: res.params,
                data,
                header: res.header
            };
        }
        return {
            url: fullUrl,
            params,
            data,
            header
        };
    }
    static getOptions(url, params = {}, isSendHeaderInfo = true, APIKEY, data) {
        let header = {};
        if (isSendHeaderInfo) {
            header = NetworkUtil.getRequestHeader(APIKEY);
        }
        const res = NetworkUtil.encryParams(params, header, url, APIKEY, data);
        return res;
    }
    static getFullUrl(subUrl, APIKEY) {
        let url = subUrl || "";
        if (url.startsWith("http") || subUrl.startsWith("https")) {
            return url;
        }
        return StringUtil.urlConcat(NetworkUtil.getConfig(APIKEY).basicUrl || "", subUrl);
    }
    static convertResponseData(responseData) {
        return responseData;
    }
    static getRequestHeader(APIKEY) {
        const header = NetworkUtil.getConfig(APIKEY).header || {};
        return header;
    }
    static cancelUpload(taskId, APIKEY) {
        const uploadInterface = NetworkUtil.getConfig(APIKEY).uploadFileInterface;
        if (uploadInterface) {
            uploadInterface.cancelUpload(taskId);
        } else {
            console.log(`"${APIKEY}"\u8FD8\u6CA1\u6709\u8BBE\u7F6E"uploadFileInterface"\uFF0C\u8BF7\u5148\u8C03\u7528"NetWorkUtil.setConfig"\u8FDB\u884C\u8BBE\u7F6E\u3002`);
        }
    }
    static request(method, fullUrl, data, header, APIKEY) {
        return NetworkUtil.getConfig(APIKEY).httpRequestService.request(method, fullUrl, data, header);
    }
};
NetworkUtil._defaultKey = "DEFAULT_NETWORK_CONFIG";
NetworkUtil._map = /* @__PURE__ */ new Map();
NetworkUtil.Get = /*#__PURE__*/ _asyncToGenerator(function*(url = "", params = {}, isSendHeaderInfo = true, APIKEY) {
    const options = NetworkUtil.getOptions(url, params, isSendHeaderInfo, APIKEY);
    const responseData = yield NetworkUtil.getConfig(APIKEY).httpRequestService.getRequest(options.url, options.params, options.header);
    return NetworkUtil.convertResponseData(responseData);
});
NetworkUtil.Post = /*#__PURE__*/ _asyncToGenerator(function*(url = "", params = {}, isSendHeaderInfo = true, APIKEY, onUploadProgress, responseType) {
    const options = NetworkUtil.getOptions(url, params, isSendHeaderInfo, APIKEY);
    const responseData = yield NetworkUtil.getConfig(APIKEY).httpRequestService.postRequest(options.url, options.params, options.header, onUploadProgress, responseType);
    return NetworkUtil.convertResponseData(responseData);
});
NetworkUtil.Put = /*#__PURE__*/ _asyncToGenerator(function*(url = "", params = {}, isSendHeaderInfo = true, APIKEY) {
    const options = NetworkUtil.getOptions(url, params, isSendHeaderInfo, APIKEY);
    const responseData = yield NetworkUtil.getConfig(APIKEY).httpRequestService.putRequest(options.url, options.params, options.header);
    return NetworkUtil.convertResponseData(responseData);
});
NetworkUtil.Delete = /*#__PURE__*/ _asyncToGenerator(function*(url = "", params = {}, isSendHeaderInfo = true, APIKEY, data) {
    const options = NetworkUtil.getOptions(url, params, isSendHeaderInfo, APIKEY, data);
    const responseData = yield NetworkUtil.getConfig(APIKEY).httpRequestService.deleteRequest(options.url, options.params, options.header, options.data);
    return NetworkUtil.convertResponseData(responseData);
});
NetworkUtil.uploadFile = function() {
    var _ref = _asyncToGenerator(function*(toUrl, filePath, uploadRequest, APIKEY, returnTaskIdCallback) {
        let fullUrl = NetworkUtil.getFullUrl(toUrl, APIKEY);
        console.log("uploadFile fullUrl: ", fullUrl);
        const uploadInterface = NetworkUtil.getConfig(APIKEY).uploadFileInterface;
        if (uploadInterface) {
            return uploadInterface.uploadFileByFullUrl(fullUrl, filePath, uploadRequest, NetworkUtil.getRequestHeader(), returnTaskIdCallback);
        } else {
            console.log(`"${APIKEY}"\u8FD8\u6CA1\u6709\u8BBE\u7F6E"uploadFileInterface"\uFF0C\u8BF7\u5148\u8C03\u7528"NetWorkUtil.setConfig"\u8FDB\u884C\u8BBE\u7F6E\u3002`);
            return null;
        }
    });
    return function(toUrl, filePath, uploadRequest, APIKEY, returnTaskIdCallback) {
        return _ref.apply(this, arguments);
    };
}();
NetworkUtil.upload = /*#__PURE__*/ _asyncToGenerator(function*(url = "", params = {}, isSendHeaderInfo = true, APIKEY, onUploadProgress, responseType) {
    const options = NetworkUtil.getOptions(url, params, isSendHeaderInfo, APIKEY);
    const responseData = yield NetworkUtil.getConfig(APIKEY).httpRequestService.upload(options.url, options.params, options.header, onUploadProgress, responseType);
    return NetworkUtil.convertResponseData(responseData);
});
NetworkUtil.uploadFileProgress = function() {
    var _ref = _asyncToGenerator(function*(toUrl, filePath, uploadRequest, APIKEY, progressCallback, resultCallback) {
        let fullUrl = NetworkUtil.getFullUrl(toUrl, APIKEY);
        console.log("uploadFileProgress fullUrl: ", fullUrl);
        const uploadInterface = NetworkUtil.getConfig(APIKEY).uploadFileInterface;
        if (uploadInterface) {
            return uploadInterface.uploadFileProgressByFullUrl(fullUrl, filePath, uploadRequest, NetworkUtil.getRequestHeader(), resultCallback, progressCallback);
        } else {
            console.log(`"${APIKEY}"\u8FD8\u6CA1\u6709\u8BBE\u7F6E"uploadFileInterface"\uFF0C\u8BF7\u5148\u8C03\u7528"NetWorkUtil.setConfig"\u8FDB\u884C\u8BBE\u7F6E\u3002`);
            return null;
        }
    });
    return function(toUrl, filePath, uploadRequest, APIKEY, progressCallback, resultCallback) {
        return _ref.apply(this, arguments);
    };
}();
NetworkUtil.uploadFileInPc = function() {
    var _ref = _asyncToGenerator(function*(url, params, APIKEY) {
        let fullUrl = NetworkUtil.getFullUrl(url, APIKEY);
        const header = yield NetworkUtil.getRequestHeader(APIKEY);
        const responseData = yield NetworkUtil.getConfig(APIKEY).httpRequestService.uploadFileRequest(fullUrl, params, header);
        return responseData;
    });
    return function(url, params, APIKEY) {
        return _ref.apply(this, arguments);
    };
}();
var PontParams = class {
    constructor(){
        this.url = "";
        this.method = "GET";
    }
};
var PontRequestConfig = class {
    constructor(){
        this.autoHandleError = true;
        this.isIgnore401ErrorHandle = false;
        this.isSendHeaderInfo = true;
        this.useLoading = false;
        this.upload = false;
        this.onUploadProgress = ()=>{};
        this.responseType = void 0;
    }
};
var CubePontBasicConfig = class {
    constructor(){
        this.log = true;
        this.langId = null;
        this.deleteNullParams = true;
        this.errCallback = (message, response)=>{
            console.log(message || response.message || response.error.message);
        };
        this.errFor401Callback = (msg)=>{
            console.log(msg);
        };
        this.isSuccess = (response)=>{
            return response && response.success == true;
        };
        this.processResponseCallback = null;
        this.loadingActions = null;
    }
};
var CubePontBasicRequestConfig = class extends CubePontBasicConfig {
    get set() {
        return (config)=>{
            if (config && typeof config == "object") {
                for(const key in config){
                    if (this.hasOwnProperty(key)) {
                        this[key] = config[key];
                    }
                }
            }
            return this;
        };
    }
    get $log() {
        return (...args)=>{
            if (this.log) {
                console.log(...args);
            }
        };
    }
};
var CubePontBasicRequest = class {
    static request(obj, pontConfig = new PontRequestConfig(), APIKEY) {
        var _this = this;
        return _asyncToGenerator(function*() {
            const requestConfig = new PontRequestConfig();
            if (pontConfig && typeof pontConfig == "object") {
                for(const key in pontConfig){
                    if (Object.prototype.hasOwnProperty.call(pontConfig, key)) {
                        requestConfig[key] = pontConfig[key];
                    }
                }
            }
            const method = (obj.method || "").toLowerCase();
            const config = _this.getConfig(APIKEY);
            const langId = typeof config.langId == "string" ? config.langId : typeof config.langId == "function" ? config.langId() : "", isSuccess = config.isSuccess || ((response2)=>{
                return response2 && response2.success == true;
            }), processResponseCallback = config.processResponseCallback, error401 = config.errFor401Callback || (()=>{});
            UpdateUserUtil.refresh();
            let response = void 0;
            if (!requestConfig.upload) {
                obj.params = obj.params ? JSON.parse(JSON.stringify(obj.params)) : {};
            }
            if (langId) {
                if (method == "get") {
                    obj.params.lang = langId;
                } else if (method == "post") {
                    obj.url += `?lang=${langId}`;
                }
            }
            if (method == "get" && config.deleteNullParams) {
                for(const key1 in obj.params){
                    const val = obj.params[key1];
                    if (val === "" || val === null || val === void 0 || Array.isArray(val) && val.length == 0) {
                        delete obj.params[key1];
                    }
                }
            }
            if (requestConfig.useLoading && config.loadingActions && typeof config.loadingActions.show == "function") {
                config.loadingActions.show();
            }
            if (requestConfig.upload) {
                response = yield NetworkUtil.upload(obj.url, obj.params, requestConfig.isSendHeaderInfo, APIKEY, requestConfig.onUploadProgress, requestConfig.responseType);
            } else if (method == "get") {
                response = yield NetworkUtil.Get(obj.url, obj.params, requestConfig.isSendHeaderInfo, APIKEY);
            } else if (method == "post") {
                response = yield NetworkUtil.Post(obj.url, obj.params, requestConfig.isSendHeaderInfo, APIKEY, requestConfig.onUploadProgress, requestConfig.responseType);
            } else if (method == "delete") {
                response = yield NetworkUtil.Delete(obj.url, obj.params, requestConfig.isSendHeaderInfo, APIKEY, obj.data);
            } else if (method == "put") {
                response = yield NetworkUtil.Put(obj.url, obj.params, requestConfig.isSendHeaderInfo, APIKEY);
            } else {
                response = yield NetworkUtil.request(obj.method, obj.url, obj.params, obj.header, APIKEY);
            }
            if (requestConfig.useLoading && config.loadingActions && typeof config.loadingActions.hide == "function") {
                config.loadingActions.hide();
            }
            try {
                config.$log(`CubePont ${APIKEY || ""} ${method.toUpperCase()} ${obj.url} response: ${JSON.stringify(response, null, "	")}`);
            } catch (error) {
                config.$log(`CubePont ${APIKEY || ""} ${method.toUpperCase()} ${obj.url} error: `, error);
            }
            return new Promise((resolve, reject)=>{
                if (response) {
                    if (isSuccess(response)) {
                        if (processResponseCallback) {
                            let processResponse = processResponseCallback(response);
                            resolve(processResponse);
                        } else {
                            resolve(response);
                        }
                    } else {
                        config.$log("CubePontBasicRequest isSuccess false..");
                        if (response && response.error && response.error.code == 401) {
                            if (!requestConfig.isIgnore401ErrorHandle) {
                                error401(response.error.message, response, APIKEY);
                            }
                            reject(response.error);
                        } else {
                            if (requestConfig.autoHandleError) {
                                if (response && response.error && response.error.message && response.error.message.includes("Network Error") && langId != I18nLocaleEnum.En) {
                                    response.error.message = langId == I18nLocaleEnum.Mo ? "\u7DB2\u7D61\u932F\u8AA4" : "\u7F51\u7EDC\u9519\u8BEF";
                                }
                                CubePontBasicRequest.show(response.error ? response.error.message || "Request failed." : "Request failed.", response, APIKEY);
                                reject(response ? response.error || response : new Error("Request failed."));
                            } else {
                                reject(response ? response.error || response : new Error("Request failed."));
                            }
                        }
                    }
                } else {
                    reject(response);
                }
            });
        })();
    }
    static getKey(APIKEY) {
        return APIKEY || this._defaultKey;
    }
    static show(message, response, APIKEY) {
        const errCallback = this.getConfig(APIKEY).errCallback;
        if (typeof errCallback == "function") {
            errCallback(message, response);
        } else {
            console.log(message);
        }
    }
    static getConfig(APIKEY) {
        const key = this.getKey(APIKEY);
        return this._map.has(key) ? this._map.get(key) || new CubePontBasicRequestConfig() : new CubePontBasicRequestConfig();
    }
    static setConfig(config, APIKEY) {
        const key = this.getKey(APIKEY);
        let item = this.getConfig(key);
        if (item && item.set) {
            item = item.set(config);
        }
        this._map.set(key, item);
    }
};
CubePontBasicRequest._defaultKey = "DEFAULT_CUBEPONT_CONFIG";
CubePontBasicRequest._map = /* @__PURE__ */ new Map();
var UpdateUserUtil = class {
    static init(func) {
        this.method = func;
    }
    static refresh() {
        if (this.method) {
            this.method();
        }
    }
};
UpdateUserUtil.method = ()=>{};
var ArrayUtil = class {
    static cutReverse(source, target, length) {
        const ns = source.slice(0, source.length - target.length).slice(-length);
        ns.reverse().forEach((item)=>{
            target.unshift(item);
        });
    }
};
var BasicTypeValueConverter = class {
    static setNumber(v) {
        return !v || isNaN(v) ? void 0 : Number(v);
    }
    static setBoolean(v) {
        if (typeof v == "boolean") {
            return v;
        } else if (v === "true") {
            return true;
        } else if (v === "false") {
            return false;
        } else {
            return void 0;
        }
    }
    static setString(v) {
        if (typeof v == "string" && v) {
            return v;
        } else if (typeof v == "number") {
            return String(v);
        } else {
            return void 0;
        }
    }
};
var CommonUtils = class {
    static debounce(callback, time = 2e3) {
        if (!this.isBlocked) {
            this.isBlocked = true;
            if (typeof callback == "function") {
                callback();
            }
            setTimeout(()=>{
                this.isBlocked = false;
            }, time);
        }
    }
};
CommonUtils.isBlocked = false;
var DateUtils = class {
    static addZero(n) {
        return n < 10 ? `0${n}` : `${n}`;
    }
    static newDate(d) {
        if (typeof d == "string") {
            if (this.formatReg.ymdhms.test(d) || this.formatReg.ymd.test(d)) {
                const arr = d.split(/\s|-|:/).map(Number);
                arr[1] -= 1;
                const dc = Date;
                return new dc(...arr);
            } else {
                return new Date(d);
            }
        } else {
            return new Date(d);
        }
    }
    static getYearMonthDateHourMinuteSecond(date) {
        const newDate = this.newDate(date);
        const year = newDate.getFullYear().toString();
        let month = (newDate.getMonth() + 1).toString();
        if (month.length === 1) {
            month = "0" + month;
        }
        let ndate = newDate.getDate().toString();
        if (ndate.length === 1) {
            ndate = "0" + ndate;
        }
        let hour = newDate.getHours().toString();
        if (hour.length === 1) {
            hour = "0" + hour;
        }
        let minute = newDate.getMinutes().toString();
        if (minute.length === 1) {
            minute = "0" + minute;
        }
        let second = newDate.getSeconds().toString();
        if (second.length === 1) {
            second = "0" + second;
        }
        return year + "-" + month + "-" + ndate + " " + hour + ":" + minute + ":" + second;
    }
    static getYearMonthDateHourMinute(date) {
        const newDate = this.newDate(date);
        const year = newDate.getFullYear().toString();
        let month = (newDate.getMonth() + 1).toString();
        if (month.length === 1) {
            month = "0" + month;
        }
        let ndate = newDate.getDate().toString();
        if (ndate.length === 1) {
            ndate = "0" + ndate;
        }
        let hour = newDate.getHours().toString();
        if (hour.length === 1) {
            hour = "0" + hour;
        }
        let minute = newDate.getMinutes().toString();
        if (minute.length === 1) {
            minute = "0" + minute;
        }
        return year + "-" + month + "-" + ndate + " " + hour + ":" + minute;
    }
    static getYearMonthDate(date) {
        const newDate = this.newDate(date);
        const year = newDate.getFullYear().toString();
        let month = (newDate.getMonth() + 1).toString();
        if (month.length === 1) {
            month = "0" + month;
        }
        let ndate = newDate.getDate().toString();
        if (ndate.length === 1) {
            ndate = "0" + ndate;
        }
        return year + "-" + month + "-" + ndate;
    }
    static getYearMonth(date) {
        const newDate = this.newDate(date);
        const year = newDate.getFullYear().toString();
        let month = (newDate.getMonth() + 1).toString();
        if (month.length === 1) {
            month = "0" + month;
        }
        return year + "-" + month;
    }
    static toLocaleDate(date = new Date()) {
        const nd = this.newDate(date), y = nd.getFullYear(), m = nd.getMonth(), d = nd.getDate();
        return new Date(y, m, d);
    }
    static getDateStart(date = new Date()) {
        return DateUtils.toLocaleDate(date);
    }
    static getDateEnd(date = new Date()) {
        return new Date(DateUtils.toLocaleDate(date).getTime() + 24 * 60 * 60 * 1e3 - 1);
    }
    static getCurrentMonthFirstDate(date = new Date()) {
        return new Date(DateUtils.toLocaleDate(date).setDate(1));
    }
    static getCurrentMonthLastDate(date = new Date()) {
        const newDate = new Date(date);
        let nextMonth = newDate.getMonth() + 1;
        let nextMonthFirstDay = new Date(newDate.getFullYear(), nextMonth, 1);
        return new Date(nextMonthFirstDay.getTime() - 1);
    }
    static getSeasonFirstDate(year, season) {
        const date = new Date(year, (season - 1) * 3);
        return new Date(DateUtils.toLocaleDate(date).setDate(1));
    }
    static getSeasonLastDate(year, season) {
        const newDate = new Date(year, season * 3 - 1);
        let nextMonth = newDate.getMonth() + 1;
        let nextMonthFirstDay = new Date(newDate.getFullYear(), nextMonth, 1);
        return new Date(nextMonthFirstDay.getTime() - 1);
    }
    static getRemainingDate(date, dateNow = new Date()) {
        let resultObj = new RemainiObject();
        const end = this.newDate(date);
        const now = this.newDate(dateNow);
        if (new Date(date).valueOf() - new Date(now).valueOf() < 0) {
            resultObj.expired = true;
            return resultObj;
        }
        const ye = end.getFullYear();
        const me = end.getMonth() + 1;
        const de = end.getDate();
        const yn = new Date(now).getFullYear();
        const mn = new Date(now).getMonth() + 1;
        const dn = new Date(now).getDate();
        let d = de - dn;
        let m = me - mn;
        let y = ye - yn;
        if (d < 0) {
            d = new Date(yn, mn, 0).getDate() + d;
            m -= 1;
        }
        if (m < 0) {
            m = 12 + m;
            y -= 1;
        }
        resultObj.year = y;
        resultObj.month = m;
        resultObj.date = d;
        resultObj.result = "";
        if (y > 0) {
            resultObj.result += y + "\u5E74";
        }
        if (m > 0) {
            resultObj.result += m + "\u500B\u6708";
        }
        if (d > 0) {
            resultObj.result += d + "\u5929";
        }
        if (y === 0 && m === 0 && d === 0) {
            let hour = end.getHours() - now.getHours();
            let min = end.getMinutes() - now.getMinutes();
            if (min < 0) {
                min = 60 + min;
                hour -= 1;
            }
            resultObj.hour = hour;
            resultObj.minute = min;
            if (hour > 0) {
                resultObj.result += hour + "\u5C0F\u6642";
            }
            if (min > 0) {
                resultObj.result += min + "\u5206\u9418";
            }
        }
        return resultObj;
    }
    static newUtcDate(date = new Date()) {
        const newDate = this.newDate(date), a = newDate.getFullYear(), b = newDate.getMonth(), c = newDate.getDate(), d = newDate.getHours(), e = newDate.getMinutes(), f = newDate.getSeconds(), g = newDate.getMilliseconds();
        return new Date(Date.UTC(a, b, c, d, e, f, g));
    }
    static getTimezoneDateStringFormLocaleDate(timezone = 8) {
        const offset = new Date().getTimezoneOffset();
        const nowDate = new Date().getTime();
        const targetDate = new Date(nowDate + offset * 60 * 1e3 + timezone * 60 * 60 * 1e3);
        return DateUtils.getYearMonthDateHourMinuteSecond(targetDate);
    }
    static newTimezoneDate(date, timezone) {
        const nowDateNumber = this.newDate(date).getTime();
        const offset = new Date().getTimezoneOffset();
        const targetDate = new Date(nowDateNumber - offset * 60 * 1e3 - timezone * 60 * 60 * 1e3);
        return targetDate;
    }
    static timestamp() {
        const date = new Date();
        const y = date.getFullYear(), m = date.getMonth(), d = date.getDate(), h = date.getHours();
        return new Date(y, m, d, h).getTime() / 1e3;
    }
    static autoCompleteTimeStamp(timestamp) {
        const l = timestamp.toString().length;
        for(let i = 0; i < 13 - l; i++){
            timestamp *= 10;
        }
        return timestamp;
    }
    static format(date, type) {
        const d = this.newDate(date);
        const YYYY = this.addZero(d.getFullYear()), MM = this.addZero(d.getMonth() + 1), DD = this.addZero(d.getDate()), hh = this.addZero(d.getHours()), mm = this.addZero(d.getMinutes()), ss = this.addZero(d.getSeconds());
        return type.replace("YYYY", YYYY).replace("MM", MM).replace("DD", DD).replace("hh", hh).replace("mm", mm).replace("ss", ss);
    }
    static getDay(date) {
        const days = [
            "\u65E5",
            "\u4E00",
            "\u4E8C",
            "\u4E09",
            "\u56DB",
            "\u4E94",
            "\u516D"
        ];
        const d = this.newDate(date);
        const day = d.getDay();
        return {
            label: `\u5468${days[day]}`,
            value: day
        };
    }
};
DateUtils.formatReg = {
    ymdhms: /\d{4}-\d{1,2}-\d{1,2}\s\d{1,2}:\d{1,2}:\d{1,2}/,
    ymd: /\d{4}-\d{1,2}-\d{1,2}/
};
var RemainiObject = class {
    constructor(){
        this.expired = false;
        this.year = null;
        this.month = null;
        this.date = null;
        this.hour = null;
        this.minute = null;
        this.result = "\u5DF2\u8FC7\u671F";
    }
};
var FileTypes;
(function(FileTypes2) {
    FileTypes2["jpeg"] = "Jpeg";
    FileTypes2["mp4"] = "Mp4";
    FileTypes2["mpge4"] = "Mpge4";
    FileTypes2["mov"] = "Mov";
    FileTypes2["pdf"] = "Pdf";
    FileTypes2["doc"] = "Doc";
    FileTypes2["docx"] = "Docx";
    FileTypes2["xls"] = "Xls";
    FileTypes2["xlsx"] = "Xlsx";
    FileTypes2["txt"] = "Txt";
    FileTypes2["ppt"] = "Ppt";
    FileTypes2["pptx"] = "Pptx";
    FileTypes2["png"] = "Png";
    FileTypes2["gif"] = "Gif";
    FileTypes2["unknow"] = "Unknow";
})(FileTypes || (FileTypes = {}));
var ContentTypeName$1;
(function(ContentTypeName2) {
    ContentTypeName2["Jpeg"] = "image/jpeg";
    ContentTypeName2["Mp4"] = "video/mp4";
    ContentTypeName2["Mpge4"] = "video/mpeg4";
    ContentTypeName2["Mov"] = "video/x-sgi-movie";
    ContentTypeName2["Pdf"] = "application/pdf";
    ContentTypeName2["Doc"] = "application/msword";
    ContentTypeName2["Docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    ContentTypeName2["Xls"] = "application/vnd.ms-excel";
    ContentTypeName2["Xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    ContentTypeName2["Txt"] = "text/plain";
    ContentTypeName2["Ppt"] = "application/vnd.ms-powerpoint";
    ContentTypeName2["Pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    ContentTypeName2["Png"] = "image/png";
    ContentTypeName2["Gif"] = "image/gif";
})(ContentTypeName$1 || (ContentTypeName$1 = {}));
var FileUtils = class {
    static get units() {
        return [
            {
                key: "B",
                val: 1
            },
            {
                key: "KB",
                val: 1024
            },
            {
                key: "MB",
                val: 1024 * 1024
            },
            {
                key: "GB",
                val: 1024 * 1024 * 1024
            },
            {
                key: "TB",
                val: 1024 * 1024 * 1024 * 1024
            }
        ];
    }
    static getFileSizeNumber(size) {
        if (typeof size == "number") {
            return size;
        }
        if (!size || typeof size != "string") {
            return null;
        }
        const key = size.replace(/[^a-zA-Z]/g, "").charAt(0).replace(/^B/, "").toUpperCase() + "B";
        const item = this.units.find((u)=>u.key == key);
        const unit = item ? item.val : 1;
        return +size.replace(/[^\d]/g, "") * unit;
    }
    static getFileSizeString(size, fractionDigits = 2) {
        size = +size;
        if (!size) {
            return "0B";
        }
        for(let i = 0; i < this.units.length; i++){
            const u = this.units.reverse()[i];
            if (size >= u.val) {
                return Number((size / u.val).toFixed(fractionDigits)) + u.key;
            }
        }
        return "1B";
    }
    static isImage(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(png|jpg|gif|jpeg|webp|bmp)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isVideo(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(avi|rmvb|rm|mp4|flv|mpg)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isPDF(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(pdf)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isTXT(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(txt)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isAPK(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(apk)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isWord(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(doc|docx|dot|dotx|docm|dotm)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isExcel(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(xls|xlsx|csv|xltm)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static isPPT(str) {
        str = typeof str == "string" ? str : "";
        const reg = /\.(pptx|ppt|potx|pot)($|\?|\/|\#)/i;
        return reg.test(str);
    }
    static getFileSuffix(file) {
        const filename = typeof file == "string" ? file || "" : "";
        const index = filename.lastIndexOf(".") + 1;
        const type = filename.substr(index).toLowerCase();
        return type;
    }
    static getMimeType(file) {
        const suffix = this.getFileSuffix(file);
        const type = FileTypes[suffix] || FileTypes.unknow;
        return ContentTypeName$1[type] || type;
    }
};
var NameValue = class {
    constructor(name, value){
        this.name = name;
        this.value = value;
    }
};
var GetDateOptions = class {
    static toLocaleDate(date = new Date()) {
        const nd = new Date(date), y = nd.getFullYear(), m = nd.getMonth(), d = nd.getDate();
        return new Date(y, m, d);
    }
    static getMonthFirstDate(date = new Date()) {
        return new Date(GetDateOptions.toLocaleDate(date).setDate(1));
    }
    static getMonthLastDate(date = new Date()) {
        const newDate = new Date(date);
        let nextMonth = newDate.getMonth() + 1;
        let nextMonthFirstDay = new Date(newDate.getFullYear(), nextMonth, 1);
        return new Date(nextMonthFirstDay.getTime() - 1);
    }
    static getSeasonFirstDate(year, season) {
        const date = new Date(year, (season - 1) * 3);
        return new Date(GetDateOptions.toLocaleDate(date).setDate(1));
    }
    static getSeasonLastDate(year, season) {
        let newDate = new Date(year, season * 3 - 1), d = GetDateOptions.getLastMonth();
        if (newDate > d) {
            newDate = new Date(d.getFullYear(), d.getMonth());
        }
        let nextMonth = newDate.getMonth() + 1;
        let nextMonthFirstDay = new Date(new Date(newDate.getFullYear(), nextMonth).setDate(1) - 1);
        const res = new Date(nextMonthFirstDay.getTime() - 1);
        return res;
    }
    static getLocaleDate(date) {
        const newDate = new Date(date);
        const year = newDate.getFullYear().toString();
        let month = (newDate.getMonth() + 1).toString();
        if (month.length === 1) {
            month = "0" + month;
        }
        let ndate = newDate.getDate().toString();
        if (ndate.length === 1) {
            ndate = "0" + ndate;
        }
        return year + "-" + month + "-" + ndate;
    }
    static setLastMonth(lastMonth) {
        GetDateOptions.lastMonth = lastMonth;
    }
    static getLastMonth() {
        let res = new Date(), lm = GetDateOptions.lastMonth;
        if (lm) {
            const na = lm.split("-").map((s)=>{
                return Number(s);
            });
            res = new Date(na[0], na[1] - 1);
        }
        return res;
    }
    static byMonth(page = 1, maxResultYear = 1, isEn = false) {
        const enArr = [
            "Jan.",
            "Feb.",
            "Mar.",
            "Apr.",
            "May.",
            "Jun.",
            "Jul.",
            "Aug.",
            "Sept.",
            "Oct.",
            "Nov.",
            "Dec."
        ];
        let res = [];
        const d = GetDateOptions.getLastMonth();
        for(let n = (page - 1) * maxResultYear; n < page * maxResultYear; n++){
            const cm = n == 0 ? d.getMonth() : 11, cy = d.getFullYear() - n;
            for(let i = cm; i >= 0; i--){
                const start = GetDateOptions.getLocaleDate(GetDateOptions.getMonthFirstDate(new Date(cy, i))), end = GetDateOptions.getLocaleDate(GetDateOptions.getMonthLastDate(new Date(cy, i)));
                const name = isEn ? enArr[i - 1] + cy : cy + "\u5E74" + (i + 1) + "\u6708", value = {
                    start,
                    end
                };
                res.push(new NameValue(name, value));
            }
        }
        return res;
    }
    static bySeason(page = 1, maxResultYear = 1, isEn = false) {
        let res = [];
        const ts = [
            "\u4E00",
            "\u4E8C",
            "\u4E09",
            "\u56DB"
        ], d = GetDateOptions.getLastMonth();
        for(let n = (page - 1) * maxResultYear; n < page * maxResultYear; n++){
            const cm = n == 0 ? d.getMonth() : 11, cy = d.getFullYear() - n, mto = (cm + 1) % 3 > 0;
            let ss = Math.floor((cm + 1) / 3);
            ss = mto ? ss + 1 : ss;
            for(let i = ss; i >= 1; i--){
                const start = GetDateOptions.getLocaleDate(GetDateOptions.getSeasonFirstDate(cy, i)), end = GetDateOptions.getLocaleDate(GetDateOptions.getSeasonLastDate(cy, i));
                const name = isEn ? `Season ${i},${cy}` : `${cy}\u5E74\u7B2C${ts[i - 1]}\u5B63`, value = {
                    start,
                    end
                };
                res.push(new NameValue(name, value));
            }
        }
        return res;
    }
    static byYear(page = 1, maxResultYear = 10, isEn = false) {
        let res = [];
        const d = GetDateOptions.getLastMonth(), dy = d.getFullYear(), dm = d.getMonth();
        for(let i = (page - 1) * maxResultYear; i < page * maxResultYear; i++){
            const cy = dy - i;
            const start = GetDateOptions.getLocaleDate(new Date(cy, 0, 1)), end = GetDateOptions.getLocaleDate(new Date(cy, 11, 31) > d ? GetDateOptions.toLocaleDate(new Date(dy, dm + 1)).setDate(1) - 1 : new Date(cy, 11, 31));
            const name = isEn ? cy + "" : cy + "\u5E74", value = {
                start,
                end
            };
            res.push(new NameValue(name, value));
        }
        return res;
    }
};
GetDateOptions.lastMonth = "";
var HtmlRegExp = class {
    static htmlDecodeByRegExp(str) {
        var s = "";
        if (!str || str.length == 0) {
            return "";
        }
        s = str.replace(/&amp;/g, "&");
        s = s.replace(/&lt;/g, "<");
        s = s.replace(/&gt;/g, ">");
        s = s.replace(/&nbsp;/g, "\xA0");
        s = s.replace(/&#39;/g, "'");
        s = s.replace(/&quot;/g, '"');
        return s;
    }
};
var I18nUtil = class {
    static setLocale(locale) {
        I18nUtil.locale = locale;
    }
    static getLocale() {
        return I18nUtil.locale;
    }
    static mapIsNull(map) {
        return !map || Object.keys(map).length == 0;
    }
    static clientMapIsNull() {
        return I18nUtil.mapIsNull(I18nUtil.clientMap);
    }
    static serverMapIsNull() {
        return I18nUtil.mapIsNull(I18nUtil.serverMap);
    }
    static initClientMap(...maps) {
        Object.assign(I18nUtil.clientMap, ...maps);
    }
    static initServerMap(...maps) {
        Object.assign(I18nUtil.serverMap, ...maps);
    }
    static getTxt(...keys) {
        let arr = [];
        keys.forEach((key)=>{
            const val = I18nUtil.serverMap[key] || I18nUtil.clientMap[key] || key;
            arr.push(val);
        });
        return arr.join("");
    }
    static replace(replaceValue, ...keys) {
        let res = I18nUtil.getTxt(...keys);
        const f1 = res.includes("${t}"), f2 = res.includes("{0}");
        if (f1) {
            return res.replace(/\$\{t\}/g, String(replaceValue));
        } else if (f2) {
            return res.replace(/\{0\}/g, String(replaceValue));
        } else {
            return res;
        }
    }
    static setMap(map) {
        this.map = map || {};
    }
    static getMap() {
        return this.map;
    }
    static hasMap() {
        const res = typeof this.map == "object" ? Object.keys(this.map).length > 0 : false;
        return res;
    }
    static getTxtSsr(...keys) {
        let arr = [];
        keys.forEach((key)=>{
            let val = I18nUtil.map[key];
            if (val === null || val === void 0) {
                val = `[${key}]`;
            }
            arr.push(val);
        });
        return arr.join("");
    }
    static replaceSsr(replaceValue, ...keys) {
        let res = I18nUtil.getTxtSsr(...keys);
        const f1 = res.includes("${t}"), f2 = res.includes("{0}");
        if (f1) {
            return res.replace(/\$\{t\}/g, String(replaceValue));
        } else if (f2) {
            return res.replace(/\{0\}/g, String(replaceValue));
        } else {
            return res;
        }
    }
};
I18nUtil.locale = "zh_TW";
I18nUtil.clientMap = {};
I18nUtil.serverMap = {};
I18nUtil.map = {};
var NotificationCenter = class {
    static defaultInstance() {
        return NotificationCenter.instance;
    }
    addObserver(observer, messageName, func) {
        let observers = this.observerList.get(messageName);
        let funcs = this.funcList.get(messageName);
        if (observers === null || observers === void 0) {
            observers = new Array();
            funcs = new Array();
        }
        if (observers.includes(observer)) {
            return;
        }
        observers.push(observer);
        funcs.push(func);
        this.observerList.set(messageName, observers);
        this.funcList.set(messageName, funcs);
    }
    postNotification(messageName, object2 = void 0) {
        let funcs = this.funcList.get(messageName) || [];
        for(let index = 0; index < funcs.length; index++){
            funcs[index](object2);
        }
    }
    removeObserver(observer, messageName) {
        let observers = this.observerList.get(messageName);
        let funcs = this.funcList.get(messageName);
        if (observers !== null && observers !== void 0 && observers.length > 0) {
            let index = observers.indexOf(observer);
            if (index != -1) {
                console.log("removeObserver index = " + index);
                observers.splice(index, 1);
                console.log("funcs before delete length = " + funcs.length);
                funcs.splice(index, 1);
                console.log("funcs after delete length = " + funcs.length);
            }
        }
    }
    constructor(){
        this.observerList = /* @__PURE__ */ new Map();
        this.funcList = /* @__PURE__ */ new Map();
    }
};
NotificationCenter.instance = new NotificationCenter();
var NumberUtils = class {
    static floatPointHandle(num, point = 0) {
        const s = typeof num == "number" || typeof num == "string" ? num + "" : "";
        const a = s.split(".");
        let int = a[0], dec = "";
        if (a[1] && point > 0) {
            const reg = /^0*/;
            const p0 = a[1].match(reg)[0], b = a[1].split(reg), p1 = b[1] || b[0], n = point - p0.length;
            if (n > 0) {
                let p = Number(p1.slice(0, n)), q = Number(p1.substr(n, 1));
                if (q >= 5) {
                    p++;
                }
                dec = p > 0 ? "." + p0 + p : "";
            }
        }
        const result = Number(int + dec);
        return isNaN(result) ? 0 : result;
    }
};
var CubePhone = class {
    toString() {
        if (this.phone) {
            const nationalCode = this.nationalCode ? /^\+/.test(this.nationalCode) ? this.nationalCode : `+${this.nationalCode}` : "";
            return nationalCode ? `${nationalCode} ${this.phone}` : this.phone;
        } else {
            return "";
        }
    }
    constructor(nationalCode, phone){
        this.nationalCode = nationalCode || nationalCode == 0 ? `${nationalCode}` : "";
        this.phone = phone ? `${phone}` : "";
    }
};
var PhoneUtil = class {
    static getPhone(nationalCode, phoneNumber) {
        let phone = nationalCode ? "+" + nationalCode + " " : "";
        phone = phoneNumber ? phone + phoneNumber : phone;
        return phone;
    }
    static getPhoneByObj(obj) {
        return PhoneUtil.getPhone(obj.nationalCode, obj.phone);
    }
    static concat(code, phone) {
        code = code || "", phone = phone || "";
        if (!phone) {
            return "";
        } else if (code) {
            if (!code.toString().startsWith("+")) {
                code = "+" + code;
            }
            return code + " " + phone;
        } else {
            return phone + "";
        }
    }
    static handle(phone) {
        phone = phone || "";
        phone = phone.replace(/null/g, "");
        if (phone.split(" ").length > 1 && phone.split(" ").join("") && !/^\+/.test(phone) && !/[\/\,]/.test(phone)) {
            phone = "+" + phone;
        } else if (/\+853|\+832|\+86/.test(phone)) {
            phone = phone.replace(/\+853/g, "+853 ").replace(/\+852/g, "+852 ").replace(/\+86/g, "+86 ");
        }
        return phone;
    }
};
function PromiseAllSettled(promises, interval = 0) {
    promises = promises || [];
    return new Promise((resolve)=>{
        const data = [], len = promises.length || 0;
        let count = len;
        for(let i = 0; i < len; i++){
            const promise = promises[i];
            if (typeof promise == "function") {
                setTimeout(()=>{
                    promise().then((res)=>{
                        data[i] = {
                            status: "fulfilled",
                            value: res
                        };
                    }, (error)=>{
                        data[i] = {
                            status: "rejected",
                            reason: error
                        };
                    }).finally(()=>{
                        if (!--count) {
                            resolve(data);
                        }
                    });
                }, i * interval);
            } else {
                count--;
            }
        }
    });
}
var RegExpUtil = class {
    static createCommonRegExp(...names) {
        const rns = names.map((name)=>{
            return "\\/" + name;
        }).join("");
        return RegExp("^" + rns + "\\/?$", "i");
    }
    static createDetailRegExp(...names) {
        const rns = names.map((name)=>{
            return "\\/" + name;
        }).join("");
        return RegExp("^" + rns + "\\/[0-9]+\\/?$", "i");
    }
};
function SetIframeRouteDisabled(obj, keys) {
    for (const key of keys){
        if (obj[key]) {
            let text = obj[key].replace(/<iframe/g, '<iframe sandbox="allow-same-origin allow-forms allow-scripts "');
            obj[key] = text;
        }
    }
}
function SetNameByIntervalValue(value, prefix, unit, exception) {
    const pre = prefix ? prefix + ":" : "";
    let name = "";
    if (!value) {
        return "";
    }
    if (exception && value[0] === exception.v[0] && value[1] === exception.v[1]) {
        name = exception.n;
    } else if (!value[0] && !value[1]) {
        name = void 0;
    } else if (!value[0]) {
        name = pre + I18nUtil.replaceSsr(value[1] + unit, "Below");
    } else if (!value[1]) {
        name = pre + I18nUtil.replaceSsr(value[0] + unit, "Above");
    } else {
        name = pre + value[0] + "-" + value[1] + unit;
    }
    return name;
}
var SetPropertyUtil = class {
    static setHas(target, source, exclude = []) {
        for(const key in source){
            if (target.hasOwnProperty(key) && !exclude.includes(key)) {
                target[key] = source[key];
            }
        }
    }
    static setAll(target, source, exclude = []) {
        for(const key in source){
            if (!exclude.includes(key)) {
                target[key] = source[key];
            }
        }
    }
};
var SerializeUtil = class {
    static deserialize(classType, json2) {
        let aa = deserialize(classType, json2);
        return aa;
    }
    static serialize(object2) {
        return serialize(object2);
    }
};
var NameValueDto = class {
    constructor(name, value){
        this.name = "";
        this.value = null;
        this.name = name;
        this.value = value;
    }
};
var NameValueChildrenDto = class extends NameValueDto {
    constructor(name, value, children){
        super(name, value);
        this.children = children ? children : [];
    }
};
var NameValueActiveDto = class extends NameValueDto {
    constructor(name, value, active){
        super(name, value);
        this.active = false;
        this.active = typeof active == "boolean" ? active : false;
    }
};
var NameValueChildrenActiveDto = class extends NameValueChildrenDto {
    static init(sourceArr, keys, unlimit = false, init) {
        if (!Array.isArray(sourceArr)) {
            return [];
        }
        const namekey = keys.namekey.split(","), valueKey = keys.valueKey.split(",");
        const n1 = namekey[0], v1 = valueKey[0], n2 = namekey[1] || n1, v2 = valueKey[1] || v1;
        let options = [];
        const hasInit = typeof init == "object";
        let value2 = [];
        if (hasInit) {
            if (Array.isArray(init.value2)) {
                value2 = init.value2;
            } else {
                value2.push(init.value2);
            }
        }
        if (unlimit) {
            options.push({
                name: unlimit,
                value: void 0,
                children: [],
                active: false
            });
        }
        sourceArr.forEach((item)=>{
            const active1 = init && item[v1] == init.value1 ? true : false;
            let option = {
                name: item[n1],
                value: item[v1],
                children: [],
                active: active1
            };
            if (unlimit) {
                option.children.push({
                    name: unlimit,
                    value: void 0,
                    children: [],
                    active: false
                });
            }
            !!item[keys.childrenKey] && item[keys.childrenKey].forEach((el)=>{
                let active2 = value2.includes(el[keys.valueKey]);
                let child = {
                    name: el[n2],
                    value: el[v2],
                    active: active2
                };
                option.children.push(child);
            });
            options.push(option);
        });
        return options;
    }
    constructor(name, value, children, active){
        super(name, value, children);
        this.active = false;
        this.active = typeof active == "boolean" ? active : false;
    }
};
var NameValueIconActiveDto = class extends NameValueActiveDto {
    constructor(name, value, icon){
        super(name, value);
        this.icon = "";
        this.icon = icon;
    }
};
var NameValueIconChildrenActiveDto = class extends NameValueChildrenActiveDto {
    constructor(icon, name, value, children, active){
        super(name, value, children, active);
        this.icon = "";
        this.icon = icon;
    }
};
var BaseAttachmentCreateRequest = class {
    constructor(){
        this.ContentType = "";
        this.Name = "file";
        this.FileName = "test.jpg";
    }
};
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
var ABPErrorDto = class {
    constructor(){
        this.message = void 0;
        this.code = void 0;
    }
};
__decorate([
    serializable,
    __metadata("design:type", String)
], ABPErrorDto.prototype, "message", void 0);
__decorate([
    serializable,
    __metadata("design:type", Number)
], ABPErrorDto.prototype, "code", void 0);
var BaseResponse = class {
    constructor(){
        this.__abp = void 0;
        this.success = void 0;
        this.error = void 0;
    }
};
__decorate([
    serializable,
    __metadata("design:type", Boolean)
], BaseResponse.prototype, "__abp", void 0);
__decorate([
    serializable,
    __metadata("design:type", Boolean)
], BaseResponse.prototype, "success", void 0);
__decorate([
    serializable(object(ABPErrorDto)),
    __metadata("design:type", ABPErrorDto)
], BaseResponse.prototype, "error", void 0);
var BaseErrorResponse = class extends BaseResponse {
    init(code, message) {
        this.error.code = code;
        this.error.message = message;
    }
    constructor(){
        super();
        this.__abp = false;
        this.success = false;
        this.error = new ABPErrorDto();
    }
};
var BaseIdResponse = class extends BaseResponse {
    constructor(){
        super(...arguments);
        this.result = void 0;
    }
};
__decorate([
    serializable,
    __metadata("design:type", Number)
], BaseIdResponse.prototype, "result", void 0);
var BaseListRequest = class {
    constructor(){}
};
__decorate([
    serializable,
    __metadata("design:type", String)
], BaseListRequest.prototype, "Sorting", void 0);
__decorate([
    serializable,
    __metadata("design:type", Number)
], BaseListRequest.prototype, "SkipCount", void 0);
__decorate([
    serializable,
    __metadata("design:type", Number)
], BaseListRequest.prototype, "MaxResultCount", void 0);
var ContentTypeName;
(function(ContentTypeName2) {
    ContentTypeName2["Jpeg"] = "image/jpeg";
    ContentTypeName2["Mp4"] = "video/mp4";
    ContentTypeName2["Mpge4"] = "video/mpeg4";
    ContentTypeName2["Mov"] = "video/x-sgi-movie";
    ContentTypeName2["Pdf"] = "application/pdf";
    ContentTypeName2["Doc"] = "application/msword";
    ContentTypeName2["Docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    ContentTypeName2["Xls"] = "application/vnd.ms-excel";
    ContentTypeName2["Xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    ContentTypeName2["Txt"] = "text/plain";
    ContentTypeName2["Ppt"] = "application/vnd.ms-powerpoint";
    ContentTypeName2["Pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    ContentTypeName2["Png"] = "image/png";
    ContentTypeName2["Gif"] = "image/gif";
})(ContentTypeName || (ContentTypeName = {}));
function createNetworkErrorResponseByCode(code) {
    let errorResponse = new BaseErrorResponse();
    let result = {};
    result.code = code;
    switch(code){
        case 400:
            result.message = "\u8ACB\u6C42\u53C3\u6578\u4E0D\u6B63\u78BA";
            break;
        case 401:
            result.message = "\u672A\u6388\u6B0A";
            break;
        case 403:
            result.message = "\u670D\u52D9\u5668\u62D2\u7D55\u8ACB\u6C42";
            break;
        case 404:
            result.message = "\u627E\u4E0D\u5230\u8ACB\u6C42\u7684\u5730\u5740";
            break;
        case 500:
            result.message = "\u8ACB\u6C42\u5931\u6557500\uFF0C\u8ACB\u806F\u7CFB\u7BA1\u7406\u54E1";
            break;
        case -999:
            result.message = "\u5DF2\u53D6\u6D88";
            break;
        case -1005:
            result.message = "\u7DB2\u7D61\u9023\u63A5\u7570\u5E38";
            break;
        case -1009:
            result.message = "\u7DB2\u7D61\u9023\u63A5\u7570\u5E38";
            break;
        case -1011:
            result.message = "\u670D\u52D9\u5668\u62D2\u7D55\u8ACB\u6C42";
            break;
        default:
            result.message = "\u8ACB\u6C42\u5931\u6557";
            break;
    }
    errorResponse.init(result.code, result.message);
    return errorResponse;
}
 /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */  /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ 


/***/ })

}]);